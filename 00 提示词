【】

写一个脚本，名为ConvertAudio.py，按照类似的结构组成：
1、实现一个名为ConvertBySingleText的函数，用于将单条文本转换为语音。
1.1、首先调用GradioAPI.py的TTS_API_change_sovits_weights函数，设置参数为：
{
            "sovits_path": "SoVITS_weights_v4/chenhuanVoice_e2_s352_l32.pth",
            "prompt_language": "中文",
            "text_language": "中文"
        }
1.2、然后GradioAPI.py的TTS_API_change_gpt_weights，设置参数为：
{
            "gpt_path": "GPT_weights_v4/chenhuanVoice-e15.ckpt"
        }
1.3、然后调用GradioAPI.py的TTS_API_get_tts_wav，设置参数为：
{
                "ref_wav_path": self.default_ref_wav,
                "prompt_text": "尊敬的各位评委老师，我是电机系陈欢，很荣幸向您汇报。",
                "prompt_language": "中文",
                "text_language": "中文",
                "how_to_cut": "按标点符号切",
                "top_k": 100,
                "top_p": 1,
                "temperature": 0.2,
                "ref_free": False,
                "speed": 1.15,
                "if_freeze": False,
                "inp_refs": None,
                "sample_steps": 32,
                "if_sr": True,
                "pause_second": 0.2
            }
然后再追加一个参数：
"text": "xxx"
这个由外部给定，也是ConvertBySingleText的输入参数（一个字符串），TTS_API_get_tts_wav输出参数也作为ConvertBySingleText的输出参数
                
【】
帮我采用tkinter实现一个简单的GUI程序（能够自适应窗口大小）：
1、界面上，从上倒下分为2个部分，分别命名为“配置区”和“操作区”
2、“配置区”界面布局和功能如下：
2.1、第一行第一个控件为“文件导入控件”，包含一个文本显示框（不可编辑）和一个按钮，按钮名字为“导入文件”，功能如下：
2.1.1、按下“导入文件”按钮，弹出资源管理器，让用户选中文件（只能选中json格式文件），选中文件后，文件路径显示在文本框中，同时此路径也被保存入内部的变量，供后续使用。
2.1.2、对于选中的json文件要做合法性检查，检查每一个对象中是否都包含text字段，都包含则通过，否则提示用户文件无效。
2.2、第二行第一个控件为“服务器地址输入”，包含一个文本显示框（可编辑）和一个按钮，按钮名字为“设定服务器地址”，功能如下：
2.2.1、用户首先在文本显示框内编辑地址，然后按下设定服务器地址”按钮，系统检查用户输入是否为“http://192.168.31.194:9872/”类似这样合理的网络地址格式，如果不合理，提示输入无效，如果合理，保存入内部的变量，供后续使用。
3、“操作区”界面布局和功能如下：
3.1、第一行的控件“音频转换控件”，包含一个按钮，名称为“批量转换”和一个文本显示框：用于显示批量转换过程中的日志输出：
3.2、第二行的控件为一个表格式的控件，表格的行数可以自适应增加，如果界面显示完，就增加一个下滑滚轮：
3.2.1、表格的每一行的布局为：第一个为文本显示框（可编辑），显示文本，第二个为一个固定长度文本显示框（不可编辑，3个字长度），只显示红色的字“未通过”或者绿色的字“已通过”，第三个为一个按钮“播放”，第四个为一个按钮“通过”，第五个为一个按钮“撤回”，具体功能如下：
3.2.2、当“导入文件”按钮按下，并得到文件路径后，并且文件合法有效，则统计json中包含的对象个数，根据对象个数，表格的行数与json文件中对象个数相同
3.2.3、将每一个json对象的text字段，显示在对应的表格行的第一个文本显示框中，同时第二个固定长度文本显示框默认显示未通过。
3.3：当“批量转换”按钮被按下后，功能逻辑如下：
3.3.1、从表格的第一行起，对于固定长度文本显示框内文本为“未通过”的行，将每行的文本显示框（可编辑）内的内容作为参数，调用ConvertBySingleText方法，服务器地址用“服务器地址输入”文本显示框的内容，（如果没有服务器地址，或者服务器地址不合法，当“批量转换”按钮被按下后提示“请输入服务器地址”）
3.3.2、当成功将文本转换为音频后，将返回参数的local_audio_path字段（代表音频文件的本地保存地址）与本行绑定
3.3.3、由此循环，知道将所有表格行都处理完毕，处理过程中“音频转换控件”的文本显示框会实时显示日志“正在处理第xx条，还剩余xx条。”
3.3.4、在音频转换过程中，表格行里面的所有按钮均为灰色，不可点击状态，转换完成后，恢复可点击状态。
3.3.5、点击每一行的播放按钮，会检查本行的local_audio_path字段绑定状态，如果没有绑定，提示“没有音频”，如果有绑定，则播放本行绑定的音频。
3.3.6、点击每一行的“通过”按钮，会检查本行的local_audio_path字段绑定状态，如果没有绑定，提示“没有音频”，如果有绑定，则将本行的固定长度文本显示框的内容改为“已通过”。
3.3.6、点击每一行的“撤销”按钮，会检查本行的local_audio_path字段绑定状态，如果没有绑定，提示“没有音频”，如果有绑定，则将本行的固定长度文本显示框的内容改为“未通过”。
4、你帮我仔细分析逻辑，补充没有提及的实现细节以及错误处理。


弹出资源管理器，让用户选中文件（只能选中json格式文件），选中文件后，文件路径显示在文本框中，同时此路径也被保存入内部的变量，供后续使用。



【】
1、点击每一行的通过和撤回按钮是，也需要检查一些本行是否有相应的音频文件绑定，如果没有绑定，则不能对状态列做调整，要提示“没有音频文件”

在操作区，“批量转换”的按钮旁边，增加一个“导出按钮”，点击后的功能为：
1、确认表格状态列，全部为已通过，否则提示“存在未通过的音频，无法导出”
2、如果全部为已通过，则按照从表格行上到下的顺序，将对应的音频一一拼接，成为一个大的音频，命名为ExportAudio.wav，如果存在同名文件，则覆盖
3、提取每一行内文本的内容，作为text字段，提取每一行对应的音频的文件名，作为audio字段，提取每一行对应的时长，作为furation字段，组成一个json，作为这一行的描述，将所有行的描述整合为一个大的json，输出为ExportAudioInfo.json,如果存在同名文件，则覆盖

【】
对代码进行修改，增加一个功能：
点击导入文件按钮后，选择的json文件检测合法后，将这个json文件的所有对象的text字段抽取出来，每一个对象的text字段为一行，保存为同目录位置同名的.txt文件

【】

对AudioConverterGUI_pywebview.py功能进行增强：
在操作区，“导出”按钮的右边，加入一个新按钮，按钮的初始文字为“允许编辑”，功能为：
1、点击按钮：当按钮的文字为“允许编辑”，则将表格的文本列变为内容可读可写，然后把按钮文字变为“禁止编辑”。
2、点击按钮：当按钮的文字为“禁止编辑”，则将表格的文本列变为内容只读。





【】
基于AudioConverterGUI_pywebview.py，帮我实现一个小工具，命名为TextCompareGUI_pywebview.py，软件标题改为文档比较工具
1、在配置区，显示服务器地址的文本框以及设定服务器地址的按钮去掉，更换为一个“导入解说词”控件，由一个文本框，和一个导入文件按钮组成，功能为：
1.1、功能如下：
2.1.1、按下“导入文件”按钮，弹出资源管理器，让用户选中文件（只能选中json格式文件），选中文件后，文件路径显示在文本框中，同时此路径也被保存入内部的变量，供后续使用。

帮我采用pywebview实现一个简单的GUI程序（能够自适应窗口大小），命名为TextCompareGUI_pywebview.py，软件标题为文档比较工具：
0、你可以借鉴AudioConverterGUI_pywebview.py的相关设计
1、界面上，从上倒下分为2个部分，分别命名为“配置区”和“操作区”
2、“配置区”界面布局和功能如下：
2.1、第一行第一个控件为“文件导入控件1”，包含一个文本显示框（不可编辑）和一个按钮，按钮名字为“导入分镜脚本文件”，功能如下：
2.1.1、按下“导入文件”按钮，弹出资源管理器，让用户选中文件（只能选中json格式文件），选中文件后，文件路径显示在文本框中，同时此路径也被保存入内部的变量，供后续使用。
2.1.2、对于选中的json文件要做合法性检查，检查每一个对象中是否都包含text字段，都包含则通过，否则提示用户文件无效。
2.2、第一行第一个控件为“文件导入控件2”，包含一个文本显示框（不可编辑）和一个按钮，按钮名字为“导入解说词文件”，功能如下：
2.2.1、按下“导入文件”按钮，弹出资源管理器，让用户选中文件（只能选中md格式文件），选中文件后，文件路径显示在文本框中，同时此路径也被保存入内部的变量，供后续使用。
3、“操作区”界面布局和功能如下：
3.1、第一行为一个日志显示框，显示软件运行过程中的各种日志信息，可以显示5行，滚动显示。
3.2、第二行分为2列，左右2列宽度占比为左边占三分之二，右边占三分之一：
3.2.1、第二行第2列的控件为文本显示框（不可编辑，但可以从中复制），命名为“解说词显示框”，当“导入解说词文件”按钮按下，并得到文件路径后，并且文件合法有效，将文件的内容以文本形式显示在文本显示框中。
3.2.2、第二行第1列的控件为一个表格式的控件，表格的行数可以自适应增加，如果界面显示完，就增加一个下滑滚轮
3.2.2.1、表格的每一行的布局为：第一个为文本显示框（可编辑），显示文本，第二个为一个按钮“定位”，第三个为一个按钮“保存”，第五个为一个按钮“撤回”，具体功能如下：
3.2.2.2、当“导入分镜脚本文件”按钮按下，并得到文件路径后，并且文件合法有效，则统计json中包含的对象个数，根据对象个数，表格的行数与json文件中对象个数相同
3.2.2.3、将每一个json对象的text字段，显示在对应的表格行的第一个文本显示框中
3.2.2.4、当某一行的“定位”按钮被按下，从本行的文本显示框中的文本，随机截取连续4个字符（中间不含标点）并统计这4个字符中第一个字符距离本行文本第一个字符的字数，记为字数1，统计这4个字符中第4个字符距离本行文本最后一个字符的字数，记为字数二。
3.2.2.5、将这4个字符在解说词显示框内的文本内容中匹配，如果匹配到，则从匹配的位置往前字数1加10个字，以及往后字数2加10个字，蓝色加粗显示，并让蓝色加粗子的这段文字位于解说词显示框的中间。
3.2.2.6、当某一行的“保存”按钮被按下，为选中的json文件，创建一个以原文件名+edit.json的文件（如果已经有了，则不用新创建），新创建时，首先复制原来json的内容，然后将从本行的文本显示框中的文本，替换新json文件与本行对应的json对象的text字段。

随机截取连续4个字符（中间不含标点）并统计这4个字符中第一个字符距离本行文本第一个字符的字数，记为字数1，统计这4个字符中第4个字符距离本行文本最后一个字符的字数，记为字数二。

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在配置区加入一行：输出文件地址组件，包含：
1.1、1个文本显示框，只读；一个按钮（文字为设置输出文件夹）
1.2、点击输出文件夹后，弹出资源管理器，选择输出文件夹，选中后，将此路径显示在文本显示框中，并且此路径作为后续生成音频的保存路径以及最终导出文件的保存路径
1.3、导出的ExportAudioInfo.json的audio字段要显示对应分镜的音频的绝对路径

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在操作区的表格控件增加一列：列标题为字幕，对应的每一行有一个按钮，按钮的文字初始为“展开”，当按钮被点击时：
1.1、如果按钮文字为“展开”，则在表格的本行内部，嵌入一个二级子表格，显示出来，二级子表格的每列标题依次为：时间戳，字幕内容，状态、操作
1.2、时间戳列的每一行，为只读文本显示框，显示本分镜对应的字幕文件的对应行的时间戳（如果是第一行，则是字幕的第一行的时间戳），如果字幕文件不存在，则显示不存在
1.3、字幕内容列的每一行，为只读文本显示框，显示本分镜对应的字幕文件的对应行的字幕内容（如果是第一行，则是字幕的第一行的字幕内容），如果字幕文件不存在，则显示不存在
1.5、状态列为一个文本，要么为绿色“已通过”，要么为红色“未通过”，初始为“未通过”
1.4、操作列有两个按钮，文字分别为：通过和撤回，点击通过按钮，状态列的本行文本显示为绿色“已通过”，点击撤回按钮，状态列的本行文本显示为红色“未通过”




【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在配置区的服务器地址增加一行，可以再设置一个服务器地址（文本框+按钮），原来的按钮文字改为“设定转音频服务器地址”，新增行的按钮文字为”设定字幕服务器地址“，设定服务器地址的逻辑与原来设定服务器地址的逻辑相同
2、在操作区，导出按钮右边，新增一个“批量转换字幕”按钮
3、批量转换字幕按钮按下时（检查配置区所有要设置的参数是否正确设置，否则提示先设置缺少的参数）：
3.1、以字幕服务器地址、输入的json文件地址、输出文件夹，为参数，调用BuzzAPI的批量转换字幕的函数，将音频转换为字幕
3.2、转换完毕后，重新执行一次json文件导入，更新相关信息

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在操作区，批量转换字幕按钮右边，新增一个“优化字幕”按钮
2、优化字幕按钮按下时：
2.1、遍历每一个分镜json对象，如果字幕的状态存在未通过的，把text字段内容作为原始文稿参数、把SRT_Path字段的srt文件的内容作为字幕文件内容参数，调用ImproveSrtResultsLLM.py，将返回内容写入SRT_Path字段的srt文件（覆盖原来内容），如果字幕状态是全部通过的，则跳过
2.2、优化过程中，显示实施进展在日志中
2.3、全部优化完毕后，将导入的json文件重新导入一下，更新信息

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在配置区的服务器地址增加一行，可以再设置一个服务器地址（文本框+按钮），新增行的按钮文字为”设定视频服务器地址“，设定服务器地址的逻辑与原来设定服务器地址的逻辑相同
2、在配置区底部增加一行，为“视频梗概文件导入”组件，包含一个文本显示框（不可编辑）和一个按钮，按钮名字为“导入视频梗概文件”，功能如下：
2.1、按下“导入视频梗概文件”按钮，弹出资源管理器，让用户选中文件（只能选中.txt或者.md格式文件），选中文件后，文件路径显示在文本框中，同时此路径（称为：“视频梗概文件路径”）也被保存入内部的变量，供后续使用。
3、在配置区底部继续增加一行，为“设定AutoDL网站token”组件，包含一个文本显示框（可编辑）和一个按钮，按钮名字为“设定AutoDL网站token”，功能如下：
3.1、用户首先在文本显示框内编辑token，然后按下“设定AutoDL网站token”按钮，将用户输入的AutoDL网站token保存入内部的变量，供后续使用。
4、在配置区底部继续增加一行，为“设定实例id”组件，包含一个文本显示框（可编辑）和一个按钮，按钮名字为“设定实例id”，功能如下：
4.1、用户首先在文本显示框内编辑实例id，然后按下“设定实例id”按钮，将用户输入的实例id保存入内部的变量，供后续使用。

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：

1、在操作区的表格控件增加一列：列标题为视频，对应的每一行有一个按钮，按钮的文字初始为“展开”，当按钮被点击时：
1.1、如果按钮文字为“展开”，则在表格的本行下方，嵌入一个二级子表格（与字幕的二级表格采用相同实现方式），显示出来，二级子表格的每列标题依次为：提示词，图片，视频
1.2、提示词列的每一行，从左到右，分别为“查看提示词”按钮，和状态按钮（按钮的文字要么为绿色“已通过”，要么为红色“未通过”）
1.2.1、点击“查看提示词”按钮，弹出一个窗口，窗口中包含4个文本显示框（窗口尺寸自动调整，确保将需要显示的信息都完整显示），分别显示本行对应的分镜信息json文件中的json对象的不同字段信息：第一个文本显示框的标题为“章节名”，显示chapter字段信息（如果不存在此字段，则显示“不存在信息”）、第二个文本显示框的标题为“分镜描述”，显示description字段信息（如果不存在此字段，则显示“不存在信息”）、第三个文本显示框的标题为“首帧提示词”，显示Prompt_Figure字段信息（如果不存在此字段，则显示“不存在信息”）、第四个文本显示框的标题为“视频提示词”，显示Prompt_Video.Process字段信息（如果不存在此字段，则显示“不存在信息”）。
1.2.2、对于状态按钮，初始化的时候，读取本行对应的分镜信息json文件中的json对象的Prompt_Update_Flag字段，如果为0，则显示绿色的“已通过”，如果为1（或者不存在字段），则显示红色的“未通过”。
1.2.3、当按钮显示绿色的“已通过”时，点击按钮，按钮文字变为红色的“未通过”，同时将Prompt_Update_Flag字段设置为1。
1.2.4、当按钮显示红色的“未通过”时，点击按钮，按钮文字变为绿色的“已通过”，同时将Prompt_Update_Flag字段设置为0。
1.3、图片列和视频列暂时空置。

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、对于视频对应的嵌入一个二级子表格，扩充其图片列：
2、图片列的每一行，从左到右，分别为图片显示框，和状态按钮（按钮的文字要么为绿色“已通过”，要么为红色“未通过”）：
2.1、图片显示框为一个不超过320*320的区域，显示本分镜的json对象的Figure.filepath路径指示的图片，如果图片不存在，则在日志区显示“图片不存在”。
2.2、对于状态按钮，初始化的时候，读取本行对应的分镜信息json文件中的json对象的Figure_Update_Flag字段，如果为0，则显示绿色的“已通过”，如果为1，则显示红色的“未通过”。
2.3、当按钮显示绿色的“已通过”时，点击按钮，按钮文字变为红色的“未通过”，同时将Figure_Update_Flag字段设置为1。
2.4、当按钮显示红色的“未通过”时，点击按钮，按钮文字变为绿色的“已通过”，同时将Figure_Update_Flag字段设置为0。

需要更换实现方式，考虑使用Python后端通过base64编码来提供图片数据。

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在操作区，优化字幕按钮右边，增加两个按钮用于控制批量展开视频以及字幕二级表格：
2、第一个按钮的文字初始化时为：“批量展开字幕”
2.1、当文字为“批量展开字幕”状态时，点击按钮，将所有分镜的字幕二级表格展开，同时文字变为“批量收起字幕”
2.1、当文字为“批量收起字幕”状态时，点击按钮，将所有分镜的字幕二级表格收起，同时文字变为“批量展开字幕”
3、第二个按钮的文字初始化时为：“批量展开视频”
2.1、当文字为“批量展开视频”状态时，点击按钮，将所有分镜的视频二级表格展开，同时文字变为“批量收起视频”
2.1、当文字为“批量收起视频”状态时，点击按钮，将所有分镜的视频二级表格收起，同时文字变为“批量展开视频”

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、对于视频对应的嵌入一个二级子表格，扩充其视频列：
2、视频列的每一行，从左到右，分别为视频显示框，和状态按钮（按钮的文字要么为绿色“已通过”，要么为红色“未通过”）：
2.1、视频显示框为一个不超过320*320的区域（在此范围内自动适应大小，不要留空白，比如显示范围是320*240，那么视频显示框就是320*240大小的），显示本行对应的分镜信息json文件中的json对象的Video.filepath路径指示的视频，如果视频不存在，则在日志区显示“视频不存在”。视频框内能够显示视频播放进度条，可以控制启停。
2.2、对于状态按钮，初始化的时候，读取本行对应的分镜信息json文件中的json对象的Video_Update_Flag字段，如果为0，则显示绿色的“已通过”，如果为1，则显示红色的“未通过”。
2.3、当按钮显示绿色的“已通过”时，点击按钮，按钮文字变为红色的“未通过”，同时将Video_Update_Flag字段设置为1。
2.4、当按钮显示红色的“未通过”时，点击按钮，按钮文字变为绿色的“已通过”，同时将Video_Update_Flag字段设置为0。
【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在配置区的“配置区”三个字左边，增加一个按钮，文字为“导入配置”：
2、点击“导入配置“按钮后：
2.1、检查脚本同目录下是否存在AllInOneToolConfig.json文件，不存在则在日志区提示：没有找到配置文件
2.2、如果配置文件存在，则检查json文件是否存在AudioServer、AudioServer、AutoDL_Token、AutoDL_ID字段，如果不全部存在，提示：配置文件不完整
2.3、如果配置文件完整，则：
2.3.1、读取AudioServer字段内容，设定为转音频服务器地址，并显示在对应文本框
2.3.2、读取SrtServer字段内容，设定为字幕服务器地址，并显示在对应文本框
2.3.3、读取VideoServer字段内容，设定为视频服务器地址，并显示在对应文本框
2.3.2、读取AutoDL_Token字段内容，设定为AutoDL网站token，并显示在对应文本框
2.3.3、读取AutoDL_ID字段内容，设定为实例id，并显示在对应文本框

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、对导出按钮的逻辑进行修改：
1.1、导出时候，将分镜音频的状态也持久化写入到ExportAudioInfo.json，用Audio_Update_Flag字段存储，如果音频状态为未通过，Audio_Update_Flag字段值为1，否则为0。

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在操作区，优化字幕按钮和批量展开/收起字幕按钮中间，加入一个批量生成视频按钮。
2、初始化时，此按钮文字为：“批量生成视频”。
3、当按钮文字为：“批量生成视频”时，点击按钮：
3.1、按钮文字变为“生成中”，并且，调用GenerateVideo.py的BatchGenerateAll_AutoDL_Management函数，将分镜信息json文件路径、输出文件夹路径、视频服务器地址、AutoDL网站token、实例id、视频梗概文件路径对应的文件的文本内容作为参数，当BatchGenerateAll_AutoDL_Management函数执行完毕，按钮文字变为“批量生成视频”。

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、对导出按钮的逻辑进行修改：
1.1、导出时候，将分镜音频的状态也持久化写入到ExportAudioInfo.json，用Audio_Update_Flag字段存储，如果音频状态为未通过，Audio_Update_Flag字段值为1，否则为0。

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、点击批量转换字幕时：
1.1、将原来的json文件备份，放在输出文件夹下，名字为“原名字_时间戳”
1.2、首先检查每个分镜的字幕子表格的状态列的显示状态，如果均为通过，则将SRT_Update_Flag字段写入本分镜的json对象，并赋值为0.
1.3、其他情况则则将SRT_Update_Flag字段写入本分镜的json对象，并赋值为1.
1.4、将全部分镜信息保存为新的json文件，名字与原来json文件一致，且放在输出文件夹下
1.5、然后按照之前代码逻辑继续执行

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、在视频子表格的视频列的已通过/未通过按钮的下面，增加一个与按钮同宽的文本显示框：
1.1、当分镜视频存在的时候，在文本显示框中显示视频的时长（单位为秒），如果不存在，则显示为空
1.2、视频的时长要读取实际的视频文件来计算，不从其他地方获取

【】
帮我对AudioConverterGUI_pywebview.py的功能进行增强：
1、点击优化字幕时：
1.1、对于每个分镜，检查字幕状态，如果每一条字幕的状态都为已通过，则跳过这个分镜，不进行优化，否则，进行优化

【】
在BuzzAPI.py中实现一个批量转换音频到字幕文件的方法：
1、接受一个json文件输入，其结构与ExportAudioInfo.json相同，根目录下有若干个分镜对象。
2、接受服务器地址输入和输出文件夹路径输入
3、对于json文件的每个分镜json对象进行遍历：
3.1、读取audio字段，如果指向的文件不存在，则提示并跳过，如果存在，将此文件作为音频文件输入结合服务器地址输入和输出文件夹路径输入，调用API进行字幕转换，将转换的字幕重命名为与audio字段指向的音频文件相同名字，保存在输出文件夹路径下，如果文件已存在，则覆盖源文件。
4、全部转换完毕后，更新信息，写入新的json文件：将原来输入的json文件备份（名字后面加入时间戳），然后新的json文件与输入的json文件同名，并放在相同文件夹下，每一个分镜的json对象新增一个SRT_Path字段，存储对应分镜的字幕文件的绝对路径
5、测试代码中，服务器地址设置为http://116.62.7.179:10002/ 、输入json文件为D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_audio\ExportAudioInfo.json，输出文件夹为：D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_audio

【】
在BuzzAPI.py中对batch_transcribe_from_json进行功能增强：
1、在进行每一个分镜的字幕转换之前，检查一些该分镜json对象的SRT_Update_Flag字段：
1.1、如果该字段不存在，或者字段的值为1，则进行字幕转换
1.2、如果该字段的值为0，则跳过该分镜的字幕转换




【】
参照GenerationPromptLLM.py帮我实现一个脚本，名字为ImproveSrtResultsLLM.py，要求如下：
1、系统提示词调整为：
你精通字幕校对工作，你的任务是根据我提供给你的原始文稿和软件识别的字幕文件（存在不准确），为我校对字幕：
1、忠于字幕文件识别的断句，不要擅自修改
2、禁止修改时间线的内容
2、根据原始文稿，纠正字幕文件识别的文字错误，标点错误（中间的标点符号需要，结尾的标点符号根据情况保留，叹号，问号等可以保留）等。

给你提供的原始文稿示例如下：
大家好，欢迎收看本期节目。今天，我们将一同走进一个普通人既熟悉又陌生的世界——国际机场。

给你提供的字幕文件内容示例如下：
1
00:00:00,000 --> 00:00:02,240
大家好 欢迎收看本期节目

2
00:00:02,240 --> 00:00:04,360
今天我们将一同走进一个

3
00:00:04,360 --> 00:00:07,160
普通人计熟悉陌生的世界国际机场

你直接输出修改后的字幕文件内容给我，如下：
1
00:00:00,000 --> 00:00:02,240
大家好 欢迎收看本期节目

2
00:00:02,240 --> 00:00:04,360
今天我们将一同走进一个

3
00:00:04,360 --> 00:00:07,160
我们将一同走进一个普通人既熟悉又陌生的世界——国际机场



你直接输出json格式给我，包含
1、原分镜信息json中的text、audio、duration、chapter字段的信息
2、description字段：优化或修改后的分镜描述信息
3、Prompt_Figure字段：生成此分镜视频首帧的提示词
4、Prompt_Video字：根据视频首帧图片生成此分镜视频的提示词

2、用户提示词由两段，做成参数，可以从外部分别给定
2.1、第一个是原始文稿、第二个是字幕文件内容
3、其余部分，相应修改。
4、对于测试函数：
用户提示词的原始文稿可以用：
对于我们大多数人来说，机场是旅行的起点和终点，是充满期待和疲惫的中转站。但对于一群特殊的人来说，这里却是危机四伏的战场，
字幕文件内容可以用：
1
00:00:00,000 --> 00:00:02,000
对于我们大多数人来说

2
00:00:02,000 --> 00:00:04,000
机场是旅行的起点和终点

3
00:00:04,000 --> 00:00:07,000
是充满期待和疲惫的中转站

4
00:00:07,000 --> 00:00:09,000
但对于一群特殊的人来说

5
00:00:09,000 --> 00:00:11,000
这里却是位机似浮的战场

【】
在ConvertAudio.py里面实现一个ExportFullSRT函数（将每个分镜的SRT字幕文件合并成一个整体的字幕文件）：
1、函数接受参数如下：
1.1、一个json文件地址（测试函数中，用D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_1\ExportAudioInfo.json）
1.2、一个输出文件地址（测试函数中，用D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_1）
2、函数的功能如下：
2.1、创建一个新的空白字幕文件（称之为主字幕文件）。
2.1、遍历json文件中的每一个json对象（代表每一个分镜），读取其SRT_Path字段，并打开SRT_Path字段指示的字幕文件：
2.2、如果是第一个分镜，则时间轴偏移为0，将SRT_Path字段指示的字幕文件追加到主字幕文件
2.3、如果不是第一个分镜，则时间轴偏移为本分镜之前的所有分镜的duration字段值之和，以此时间轴偏移量，将SRT_Path字段指示的字幕文件追加到主字幕文件
2.4、遍历完毕后，将主字幕文件保存到输出文件地址，文件名与json文件地址指示的json文件相同

【】
在ConvertAudio.py里面实现一个ProcessVideos函数（将每个分镜的视频处理为长度与音频一致）：
1、函数接受参数如下：
1.1、一个json文件地址（测试函数中，用D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_1\ExportAudioInfo.json）
1.2、一个输出文件地址（测试函数中，用D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_1）
2、函数的功能如下：
2.1、遍历json文件中的每一个json对象（代表每一个分镜），读取其Video.filepath字段，并打开Video.filepath字段指示的视频文件（称之为分镜视频文件），读取其duration字段的值，称之为分镜时长：
2.2、将分镜视频文件时长处理（通过等比慢放或者快放）为与分镜时长一致，然后将原分镜视频备份（改名为原文件名_时间戳），备份后，将处理完的新分镜视频保存在原分镜视频相同文件夹，名字与原文件名相同。
2.3、遍历完毕后，将所有分镜的分镜视频文件（处理后的）合成为一个大视频，保存在输出文件夹，命名为ExportAudioInfo，如果文件已存在，则将旧文件备份（改名为原名字_时间戳）
【】
在ConvertAudio.py里面实现一个MergeAudioVideoSRT函数（将音频，字幕和视频压制为一个视频）：
1、函数接受参数如下：
1.1、一个json文件地址（测试函数中，用D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_1\ExportAudioInfo.json）
1.2、一个输出文件地址（测试函数中，用D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_1）
2、函数的功能如下：
2.1、读取与json文件同目录的同名的音频（wav），视频（mp4）和字幕文件，并将三者压制为一个新的视频：
2.2、将新的视频保存在输出文件夹，命名为与json文件相同，如果文件已存在，则将旧文件备份（改名为原名字_时间戳）

【】
在ConvertAudio.py里面实现一个ExportFullVideo函数（从json文件导出剪辑好的视频）：
1、函数接受参数如下：
1.1、一个json文件地址（测试函数中，用D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_1\ExportAudioInfo.json）
1.2、一个输出文件地址（测试函数中，用D:\05 SelfMidea\98 SelfDevelopedTools\01 BatchTTS_tool\output_1）
2、函数的功能如下：
2.1、调用ExportFullSRT处理字幕
2.2、调用ProcessVideos处理视频
2.3、调用MergeAudioVideoSRT处理合成视频

https://github.com/heroistired/BatchTTS_tool
http://116.62.7.179:10001/ 文本转语音
http://116.62.7.179:10002/ 语音转字幕
仅根据上下文总结项目得修改，并且提交远程服务器